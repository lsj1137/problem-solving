# 시뮬레이션 + BFS
from collections import deque

dx = [-1, 0, 1, 0]
dy = [0, 1, 0, -1]

class Golem:
    def __init__(self, i, x, y, exit):
        self.index, self.x, self.y, self.exit = i, x, y, exit

    def __str__(self):
        return f'Golem {self.x=} {self.y=} {self.exit=}'
    
    def canMove(self, d):
        # print('canMove',d)
        nx = self.x + dx[d]
        ny = self.y + dy[d]
        if self.somethingExist(nx,ny):
            return False
        return True
    
    def somethingExist(self, x, y):
        # print('somethingExist: ',x, y)
        for i in range(4):
            nx = x + dx[i]
            ny = y + dy[i]
            if ny<0 or nx>R-1 or ny>C-1 or (nx>-1 and forest[nx][ny]!=0):
                return True
        return False

    def rotateClock(self):
        self.exit = (self.exit+1)%4
        return

    def rotateCounterClock(self):
        self.exit = (self.exit+3)%4
        return

    def move(self):
        global total
        isMoving = True
        while isMoving:
            if self.canMove(2):
                self.x += 1
                continue
            if self.canMove(3):
                self.y -= 1
                if self.canMove(2):
                    self.x += 1
                    self.rotateCounterClock()
                    continue
                self.y += 1
            if self.canMove(1):
                self.y += 1
                if self.canMove(2):
                    self.x += 1
                    self.rotateClock()
                    continue
                self.y -= 1
            isMoving = False
        if self.x>0:
            self.stopAndApply()
            columnNum = calColumnNum(self.x, self.y)
            # print(columnNum+1)
            total += columnNum+1
        else:
            reset()
        return

    def stopAndApply(self):
        global forest
        forest[self.x][self.y] = self.index
        for i in range(4):
            nx = self.x+dx[i]
            ny = self.y+dy[i]
            if i==self.exit:
                forest[nx][ny] = -self.index
            else:
                forest[nx][ny] = self.index
        return

def reset():
    global forest
    forest = [[0]*C for _ in range(R)]
    return

def calColumnNum(x,y):
    checked = [[False]*C for _ in range(R)]
    que = deque([[x,y]])
    checked[x][y] = True
    result = x + 1
    while len(que)>0:
        cx,cy = que.popleft()
        for i in range(4):
            nx = cx+dx[i]
            ny = cy+dy[i]
            if nx>-1 and ny>-1 and nx<R and ny<C and not checked[nx][ny] and forest[nx][ny]!=0:
                if forest[cx][cy]<0 or abs(forest[nx][ny])==abs(forest[cx][cy]):
                    que.append([nx,ny])
                    checked[nx][ny] = True
                    result = max(result, nx)
    return result


R, C, K = map(int,input().split())
forest = [[0]*C for _ in range(R)]
total = 0

for k in range(1,K+1):
    c, d = map(int, input().split())
    golem = Golem(k, -2, c-1, d)
    golem.move()
    # print(golem)

print(total)
