from collections import deque

dxy = [(-1,0), (1,0), (0,-1), (0,1)]
sdxy = [[(-1,0), (-1,-1)], [(-1,0)], [(-1,0), (-1,1)], 
[(1,1), (1,0)], [(1,0)], [(1,0), (1,-1)], 
[(0,-1), (1,-1)], [(0,-1)], [(0,-1), (-1,-1)],
[(-1,1), (0,1)], [(0,1)], [(1,1), (0,1)] ]

class Medusa:
    def __init__(self, x, y):
        self.x, self.y = x, y
        self.sight = 0
        self.hit = 0

    def __str__(self):
        return f'M: {self.x},{self.y},{self.sight}'

    def move(self):
        shortest = float('inf')
        cx, cy = self.x, self.y
        for dx, dy in dxy:
            nx, ny = cx + dx, cy + dy
            if is_in(nx,ny) and distArr[nx][ny]<shortest:
                shortest = distArr[nx][ny]
                self.x,self.y = nx, ny
        return

    def checkDirection(self):
        result = []
        for i in range(4):
            refreshSightBoard()
            stunnedWarriors = simulate(self.x, self.y, i)
            result.append([stunnedWarriors, i])
        result.sort(key=lambda x:(-len(x[0]), x[1]))
        return result[0]

class Warrior:
    def __init__(self, x, y):
        self.x, self.y = x, y
        self.stun = 0
        self.die = False

    def __str__(self):
        return f'W: {self.x},{self.y}'

    def checkDeath(self):
        if self.x==medusa.x and self.y==medusa.y:
            self.die = True
        return self.die

    def move(self):
        totalMove = 0
        isMoved = False
        attack = 0
        cx, cy = self.x, self.y
        shortest = cal_dist(cx, cy, medusa.x, medusa.y)
        for dx, dy in dxy:
            nx, ny = cx+dx, cy+dy
            dist = cal_dist(nx, ny, medusa.x, medusa.y)
            if is_in(nx,ny) and not sightBoard[nx][ny] and dist<shortest:
                isMoved = True
                shortest = dist
                self.x, self.y = nx, ny
        if isMoved:
            totalMove += 1
        if self.checkDeath():
            attack += 1
            return [totalMove, attack]
        isMoved = False
        cx, cy = self.x, self.y
        shortest = cal_dist(cx, cy, medusa.x, medusa.y)
        for i in range(2,6):
            dx, dy = dxy[i%4]
            nx, ny = cx+dx, cy+dy
            dist = cal_dist(nx, ny, medusa.x, medusa.y)
            if is_in(nx,ny) and not sightBoard[nx][ny] and dist<shortest:
                isMoved = True
                shortest = dist
                self.x, self.y = nx, ny
        if isMoved:
            totalMove += 1
        if self.checkDeath():
            attack += 1
        return [totalMove, attack]


def is_in(x,y):
    return -1<x<N and -1<y<N

def cal_dist(x1, y1, x2, y2):
    return abs(x1-x2)+abs(y1-y2)

def bfs(fromX, fromY):
    que = deque([[fromX, fromY, 0]])
    checked = [[False]*N for _ in range(N)]
    checked[fromX][fromY] = True
    while len(que)>0:
        cx, cy, dist = que.popleft()
        distArr[cx][cy] = dist
        for dx, dy in dxy:
            nx, ny = cx+dx, cy+dy
            if is_in(nx, ny) and not checked[nx][ny] and board[nx][ny]!=1:
                checked[nx][ny] = True
                que.append([nx, ny, dist+1])
    return

def moveMedusa():
    medusa.move()
    for w in warriors:
        w.checkDeath()
    return

def turnHead():
    stunnedWarriors, direction = medusa.checkDirection()
    refreshSightBoard()
    simulate(medusa.x, medusa.y, direction)
    # print(sightBoard)
    for w in stunnedWarriors:
        w.stun = 1
    medusa.sight = direction
    return len(stunnedWarriors)

def moveWarriors():
    dist, attack = 0, 0
    for w in warriors:
        if w.stun==0 and not w.die:
            d, a = w.move()
            dist += d
            attack += a
    return [dist, attack]

def heal():
    for w in warriors:
        if w.stun>0:
            w.stun -= 1
    return


def refreshSightBoard():
    global sightBoard
    sightBoard = [[False]*N for _ in range(N)]
    return

def refreshWarriorBoard():
    global warriorBoard
    global warriors
    warriorBoard = [[[] for _ in range(N)] for _ in range(N)]
    newWarriors = []
    for w in warriors:
        if not w.die:
            newWarriors.append(w)
            warriorBoard[w.x][w.y].append(w)
        else:
            del w
    warriors = newWarriors
    return

def simulate(x,y,d):
    stunnedWarriors = []
    checked = [[False]*N for _ in range(N)]
    if d==0:
        if is_in(x-1, y-1):
            stunnedWarriors += updateSightBoard(x-1, y-1, 0, checked, False)
        if is_in(x-1, y):
            stunnedWarriors += updateSightBoard(x-1, y, 1, checked, False)
        if is_in(x-1, y+1):
            stunnedWarriors += updateSightBoard(x-1, y+1, 2, checked, False)
    elif d==1:
        if is_in(x+1, y+1):
            stunnedWarriors += updateSightBoard(x+1, y+1, 3, checked, False)
        if is_in(x+1, y):
            stunnedWarriors += updateSightBoard(x+1, y, 4, checked, False)
        if is_in(x+1, y-1):
            stunnedWarriors += updateSightBoard(x+1, y-1, 5, checked, False)
    elif d==2:
        if is_in(x+1, y-1):
            stunnedWarriors += updateSightBoard(x+1, y-1, 6, checked, False)
        if is_in(x, y-1):
            stunnedWarriors += updateSightBoard(x, y-1, 7, checked, False)
        if is_in(x-1, y-1):
            stunnedWarriors += updateSightBoard(x-1, y-1, 8, checked, False)
    else:
        if is_in(x-1, y+1):
            stunnedWarriors += updateSightBoard(x-1, y+1, 9, checked, False)
        if is_in(x, y+1):
            stunnedWarriors += updateSightBoard(x, y+1, 10, checked, False)
        if is_in(x+1, y+1):
            stunnedWarriors += updateSightBoard(x+1, y+1, 11, checked, False)
    return stunnedWarriors

# 시야에 들어오는 영역 체크
def updateSightBoard(x, y, d, checked, reverse):
    que = deque([[x,y]])
    checked[x][y] = True
    stunnedWarriors = []
    # 전사의 시야라면 가리기
    if reverse:
        sightBoard[x][y] = False
    # 메두사 시야면 밝히기
    else:
        sightBoard[x][y] = True
    while len(que)>0:
        cx, cy = que.popleft()
        # 시야에 전사가 있다면
        if sightBoard[cx][cy] and len(warriorBoard[cx][cy])>0:
            # 전사 뒤로 시야 가리기 작업 시작
            stunnedWarriors += warriorBoard[cx][cy]
            for dx, dy in sdxy[d]:
                nx, ny = cx + dx, cy + dy
                if is_in(nx, ny):
                    updateSightBoard(nx, ny, d, checked, True)
        # 시야 확산
        for dx, dy in sdxy[d]:
            nx, ny = cx + dx, cy + dy
            if is_in(nx, ny) and not checked[nx][ny]:
                checked[nx][ny] = True
                # 전사의 시야라면 가리기
                if reverse:
                    sightBoard[nx][ny] = False
                # 메두사 시야면 밝히기
                else:
                    sightBoard[nx][ny] = True
                que.append([nx,ny])
    return stunnedWarriors

N, M = map(int, input().split())
startX, startY, parkX, parkY = map(int, input().split())
warriorsP = list(map(int,input().split()))
warriorBoard = [[[] for _ in range(N)] for _ in range(N)]
warriors = []
for i in range(0,M*2,2):
    wx, wy = warriorsP[i], warriorsP[i+1]
    warriors.append(Warrior(wx, wy))
board = [list(map(int,input().split())) for _ in range(N)]
distArr = [[float('inf') for _ in range(N)] for _ in range(N)]
sightBoard = [[False]*N for _ in range(N)]

refreshWarriorBoard()
bfs(parkX, parkY)

if distArr[startX][startY]==float('inf'):
    print(-1)
else:
    medusa = Medusa(startX, startY)
    time = 0
    while medusa.x!=parkX or medusa.y!=parkY:
        moveMedusa()
        stunnedCount = turnHead()
        # print(medusa.sight, sightBoard)
        movedDistCount, attackCount = moveWarriors()
        refreshWarriorBoard()
        heal()
        if medusa.x!=parkX or medusa.y!=parkY:
            print(movedDistCount, stunnedCount, attackCount)
    print(0)
